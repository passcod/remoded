// Generated by CoffeeScript 1.3.1
(function() {
  var parseUri, processScopes,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.Remoded = function(manifest, loc) {
    var current_scope, domain, load, match, port, scope, scopes;
    scopes = [
      {
        matches: [],
        domains: [],
        ports: [],
        loads: [],
        children: []
      }
    ];
    loc = log(parseUri(loc));
    current_scope = 0;
    match = function(expr) {
      return scopes[current_scope].matches.push(expr);
    };
    domain = function(expr) {
      return scopes[current_scope].domains.push(expr);
    };
    port = function(expr) {
      return scopes[current_scope].ports.push(expr);
    };
    load = function() {
      var files, _ref;
      files = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (Array.isArray(files[0])) {
        files = files[0];
      }
      if (typeof files === 'string' || typeof files === 'number') {
        files = [files];
      }
      return (_ref = scopes[current_scope].loads).push.apply(_ref, files);
    };
    scope = function(call) {
      var length;
      length = scopes.push({
        contents: call,
        matches: [],
        domains: [],
        ports: [],
        loads: [],
        children: [],
        parent: current_scope
      });
      scopes[current_scope].children.push(length - 1);
      current_scope = length - 1;
      call();
      return current_scope = scopes[current_scope].parent;
    };
    eval(manifest);
    return log(processScopes(scopes, loc));
  };

  RegExp.prototype.toJSON = function() {
    return this.toString();
  };

  Function.prototype.toJSON = function() {
    return this.toString();
  };

  parseUri = function(uri) {
    var a, prop, props, protocols, result, _i, _len;
    result = {};
    a = document.createElement('a');
    props = 'protocol hostname host pathname port search hash href'.split(' ');
    a.href = uri;
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      result[prop] = a[prop];
    }
    result.toString = function() {
      return a.href;
    };
    result.requestUri = a.pathname + a.search;
    result.protocol = a.protocol.replace(':', '');
    protocols = {
      http: 80,
      https: 443,
      ftp: 21
    };
    if (protocols[result.protocol] && !a.port) {
      result.port = +protocols[result.protocol];
    }
    return result;
  };

  processScopes = function(scopes, loc) {
    var domain, instructions, match, pass, scope, _i, _len, _ref, _ref1;
    instructions = {
      load: [],
      serve: []
    };
    for (_i = 0, _len = scopes.length; _i < _len; _i++) {
      scope = scopes[_i];
      pass = true;
      pass && (pass = (_ref = loc.port, __indexOf.call(scope.ports, _ref) >= 0));
      pass && (pass = !(__indexOf.call((function() {
        var _j, _len1, _ref1, _results;
        _ref1 = scope.domains;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          domain = _ref1[_j];
          if (typeof domain === 'string') {
            domain = domain.replace(/(^\s+|\s+$)/g, '');
            _results.push(loc.hostname === domain);
          } else if (domain instanceof RegExp) {
            _results.push(domain.test(loc.hostname));
          } else {
            _results.push(true);
          }
        }
        return _results;
      })(), false) >= 0));
      pass && (pass = !(__indexOf.call((function() {
        var _j, _len1, _ref1, _results;
        _ref1 = scope.matches;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          match = _ref1[_j];
          if (typeof match === 'string') {
            match = match.replace(/(^\/?|\/?$)/g, '');
            _results.push(match === loc.pathname.replace(/(^\/?|\/?$)/g, '') + loc.search);
          } else if (match instanceof RegExp) {
            _results.push(match.test(loc.requestUri));
          } else {
            _results.push(true);
          }
        }
        return _results;
      })(), false) >= 0));
      if (pass) {
        (_ref1 = instructions.load).push.apply(_ref1, scope.loads);
      }
    }
    return instructions;
  };

}).call(this);
